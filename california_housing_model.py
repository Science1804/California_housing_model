# -*- coding: utf-8 -*-
"""California Housing Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b2D_kVsY3P4ortH413iit9D2MIASTel2
"""

import math , shutil , os
import numpy as np
import pandas as pd
import tensorflow as tf

tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.INFO)

pd.options.display.max_rows = 10
pd.options.display.float_format = '{:.1f}'.format

!git clone https://github.com/Science1804/California_housing_model

os.listdir('California_housing_model')

myfile = 'California_housing_model/california_housing_train.csv'

df = pd.read_csv(myfile,sep=',')

df.describe()

df.head()

#splitting the data using no random function to 80% for training and 20% for testing
np.random.seed(seed=1)
msk = np.random.rand(len(df)) < 0.8
traindf = df[msk]
testdf = df[~msk]

#here we try to predict the median_house_value
#please do check out the csv and try to interpret the data yourself
#so we will make input function for features columns 
#some features arn't viable to us directly so we will create new ones
#think of a column to divide bt so that we would get some co relation with median_house_value
#so typically all the rows we have are features but we are engeenering new features

def add_more_features(df):
  df['avg_rooms_per_house'] = df['total_rooms'] / df['households']
  df['avg_person_per_room'] = df['population']  / df['total_rooms']
  df['num_bedrooms'] = df['total_bedrooms'] / df['households']
  return df

#now implementing an input function that will be passed on to the model for training evaluation 
def make_input_fn(df,num_epochs):
  return tf.compat.v1.estimator.inputs.pandas_input_fn(
      x = add_more_features(df),
      y = df['median_house_value'],
      batch_size = 128,
      num_epochs = num_epochs,
      shuffle = True,
      queue_capacity = 1000,
      num_threads = 1)

def create_feature_cols():
  return [
          tf.feature_column.numeric_column('housing_median_age'),
          tf.feature_column.numeric_column('avg_rooms_per_house'),
          tf.feature_column.numeric_column('avg_person_per_room'),
          tf.feature_column.numeric_column('num_bedrooms'),
          tf.feature_column.numeric_column('median_income'),
          tf.feature_column.bucketized_column(tf.feature_column.numeric_column('latitude'),boundaries=np.arange(32.0,42,1).tolist())
  ]

def train_and_evaluate(output_dir,num_train_steps):
  estimator = tf.compat.v1.estimator.LinearRegressor(
      model_dir=output_dir,
      feature_columns=create_feature_cols())
  train_spec = tf.estimator.TrainSpec(
      input_fn = make_input_fn(traindf,None),
      max_steps = num_train_steps)
  eval_spec = tf.estimator.EvalSpec(
      input_fn=make_input_fn(testdf,1),
      steps = None,
      start_delay_secs = 1 ,
      throttle_secs = 5)
  tf.estimator.train_and_evaluate(estimator,train_spec,eval_spec)

OUTDIR = 'trained_model'
shutil.rmtree(OUTDIR,ignore_errors=True)
tf.compat.v1.summary.FileWriterCache.clear()
train_and_evaluate(OUTDIR,2000)

